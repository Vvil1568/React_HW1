//Соберем тип следующим образом:
//Для каждого ключа из множества ключей типа Т добавим опциональное поле типа DeepPartial<T[Key]>
//Если тип не был типом с полями - он так и останется этим типом. Если это был тип с полями, то
//На него применится DeepPartial и его поля тоже станут опциональными. И так рекурсивно.
export type DeepPartial<T> = {
    [Key in keyof T]? : DeepPartial<T[Key]>
};

//Наложим на Т ограничение: Т может быть только строкой.
//Произведем проверку - подходит ли Т под паттерн `${infer X}${infer Y}`
//Если да, то с помощью ключевого слова infer отсечем в Х первый символ строки Т, а в Y - оставшуюся часть строки.
//Соберем на основе Х и Y новую строку, где Х будет превращено в заглавную букву с помощью Uppercase, а затем будет следовать Y
//Если проверка не прошла, просто вернем Т.
export type MyCapitalize<T extends string> = T extends `${infer X}${infer Y}`
    ? `${Uppercase<X>}${Y}`
    : T;

//Соберем тип следующим образом:
//Для каждого ключа из множества ключей типа Т добавим изменяемое поле типа DeepMutable<T[Key]>
//Если тип не был типом с полями - он так и останется этим типом. Если это был тип с полями, то
//На него применится DeepMutable и его поля тоже станут изменяемыми. И так рекурсивно.
export type DeepMutable<T> = {
    -readonly [Key in keyof T] : DeepMutable<T[Key]>
};

//Наложим на StringElem ограничение: StringElem может быть только строкой.
//Произведем проверку - подходит ли StringElem под паттерн `${infer X}/${infer Y}`
//Если да - с помощью ключевого слова infer положим в X часть строки до /, а в Y - часть строки после /.
//После этого произведем еще одну проверку. соответствует ли строка X паттерну `:${infer Z}`. 
//Если да - с помощью ключевого слова infer отсечем ту часть строки, что идет после двоеточия и добавим ее к списку параметров. Иначе добавим never (не добавим ничего)
//Оставшуюся же часть строки, которую мы отложили в Y, рекурсивно распарсим с помощью нашего типа.
//В случае же, если строка StringElem не подходит под паттерн `${infer X}/${infer Y}`, то
//Сразу произведем проверку на соответствие строки StringElem паттерну `:${infer Z}`.
//В случае соответствия с помощью ключевого слова infer отсечем ту часть строки, что идет после двоеточия и вернем как тип. Иначе вернем never
//Таким образом, мы рекурсивно разбиваем строку по /, отсекая от начала одну часть за другой. Каждую часть добавляем к списку параметров, если она начинается с :
export type ParseURLParams<StringElem extends string> = StringElem extends `${infer X}/${infer Y}`
    ? (X extends `:${infer Z}`?Z:never) | ParseURLParams<Y>
    : (StringElem extends `:${infer Z}`?Z:never);
